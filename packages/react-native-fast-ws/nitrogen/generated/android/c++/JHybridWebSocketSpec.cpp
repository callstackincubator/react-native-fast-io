///
/// JHybridWebSocketSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2024 Marc Rousavy @ Margelo
///

#include "JHybridWebSocketSpec.hpp"

// Forward declaration of `BinaryType` to properly resolve imports.
namespace margelo::nitro::websocket { enum class BinaryType; }
// Forward declaration of `ArrayBuffer` to properly resolve imports.
namespace NitroModules { class ArrayBuffer; }
// Forward declaration of `HybridBlobSpec` to properly resolve imports.
namespace margelo::nitro::websocket { class HybridBlobSpec; }

#include "BinaryType.hpp"
#include "JBinaryType.hpp"
#include <string>
#include <NitroModules/ArrayBuffer.hpp>
#include <NitroModules/JArrayBuffer.hpp>
#include <memory>
#include "HybridBlobSpec.hpp"
#include "JHybridBlobSpec.hpp"
#include <NitroModules/JNISharedPtr.hpp>
#include <functional>
#include "JFunc_void_std__string.hpp"
#include "JFunc_void_double_std__string.hpp"
#include "JFunc_void_std__shared_ptr_ArrayBuffer_.hpp"
#include "JFunc_void_std__shared_ptr_margelo__nitro__websocket__HybridBlobSpec_.hpp"

namespace margelo::nitro::websocket {

  jni::local_ref<JHybridWebSocketSpec::jhybriddata> JHybridWebSocketSpec::initHybrid(jni::alias_ref<jhybridobject> jThis) {
    return makeCxxInstance(jThis);
  }

  void JHybridWebSocketSpec::registerNatives() {
    registerHybrid({
      makeNativeMethod("initHybrid", JHybridWebSocketSpec::initHybrid),
    });
  }

  size_t JHybridWebSocketSpec::getExternalMemorySize() noexcept {
    static const auto method = _javaPart->getClass()->getMethod<jlong()>("getMemorySize");
    return method(_javaPart);
  }

  // Properties
  BinaryType JHybridWebSocketSpec::getBinaryType() {
    static const auto method = _javaPart->getClass()->getMethod<jni::local_ref<JBinaryType>()>("getBinaryType");
    auto __result = method(_javaPart);
    return __result->toCpp();
  }
  void JHybridWebSocketSpec::setBinaryType(BinaryType binaryType) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JBinaryType> /* binaryType */)>("setBinaryType");
    method(_javaPart, JBinaryType::fromCpp(binaryType));
  }

  // Methods
  void JHybridWebSocketSpec::send(const std::string& message) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<jni::JString> /* message */)>("send");
    method(_javaPart, jni::make_jstring(message));
  }
  void JHybridWebSocketSpec::sendArrayBuffer(const std::shared_ptr<ArrayBuffer>& buffer) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JArrayBuffer::javaobject> /* buffer */)>("sendArrayBuffer");
    method(_javaPart, JArrayBuffer::wrap(buffer));
  }
  void JHybridWebSocketSpec::sendBlob(const std::shared_ptr<margelo::nitro::websocket::HybridBlobSpec>& blob) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JHybridBlobSpec::javaobject> /* blob */)>("sendBlob");
    method(_javaPart, std::dynamic_pointer_cast<JHybridBlobSpec>(blob)->getJavaPart());
  }
  void JHybridWebSocketSpec::connect() {
    static const auto method = _javaPart->getClass()->getMethod<void()>("connect");
    method(_javaPart);
  }
  void JHybridWebSocketSpec::close(double code, const std::string& reason) {
    static const auto method = _javaPart->getClass()->getMethod<void(double /* code */, jni::alias_ref<jni::JString> /* reason */)>("close");
    method(_javaPart, code, jni::make_jstring(reason));
  }
  void JHybridWebSocketSpec::ping() {
    static const auto method = _javaPart->getClass()->getMethod<void()>("ping");
    method(_javaPart);
  }
  void JHybridWebSocketSpec::onOpen(const std::function<void(const std::string& /* selectedProtocol */)>& callback) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JFunc_void_std__string::javaobject> /* callback */)>("onOpen");
    method(_javaPart, JFunc_void_std__string::fromCpp(callback));
  }
  void JHybridWebSocketSpec::onClose(const std::function<void(double /* code */, const std::string& /* reason */)>& callback) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JFunc_void_double_std__string::javaobject> /* callback */)>("onClose");
    method(_javaPart, JFunc_void_double_std__string::fromCpp(callback));
  }
  void JHybridWebSocketSpec::onError(const std::function<void(const std::string& /* error */)>& callback) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JFunc_void_std__string::javaobject> /* callback */)>("onError");
    method(_javaPart, JFunc_void_std__string::fromCpp(callback));
  }
  void JHybridWebSocketSpec::onMessage(const std::function<void(const std::string& /* message */)>& callback) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JFunc_void_std__string::javaobject> /* callback */)>("onMessage");
    method(_javaPart, JFunc_void_std__string::fromCpp(callback));
  }
  void JHybridWebSocketSpec::onArrayBuffer(const std::function<void(const std::shared_ptr<ArrayBuffer>& /* buffer */)>& callback) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JFunc_void_std__shared_ptr_ArrayBuffer_::javaobject> /* callback */)>("onArrayBuffer");
    method(_javaPart, JFunc_void_std__shared_ptr_ArrayBuffer_::fromCpp(callback));
  }
  void JHybridWebSocketSpec::onBlob(const std::function<void(const std::shared_ptr<margelo::nitro::websocket::HybridBlobSpec>& /* blob */)>& callback) {
    static const auto method = _javaPart->getClass()->getMethod<void(jni::alias_ref<JFunc_void_std__shared_ptr_margelo__nitro__websocket__HybridBlobSpec_::javaobject> /* callback */)>("onBlob");
    method(_javaPart, JFunc_void_std__shared_ptr_margelo__nitro__websocket__HybridBlobSpec_::fromCpp(callback));
  }

} // namespace margelo::nitro::websocket
